Below is the same roadmap rendered entirely in Markdown (ready to drop into a repo / Notion / Obsidian).

⸻

Stage 0 – Setup (½ week)

Goal Actions
Build muscle-memory on LeetCode UI Do five easy “Two Sum” variants: 1, 167, 653, 1099, 170. Time-box to ≤ 20 min each.
Establish baseline language template Create personal snippets for: (a) BFS queue loop, (b) DFS recursion, (c) in-place two-pointer swap, (d) priority-queue comparator.

⸻

Stage 1 – Linear Data & Sliding Patterns (≈ 2 weeks)

1. Arrays & Strings
   Patterns: prefix/suffix scan, two-pointer, reversing, string builder.
   Core problems: 121, 53, 26, 344, 125, 680
2. Hash Table & Frequency Counting
   Patterns: duplicate check, anagram grouping, running window count.
   Core: 217, 242, 49, 347, 560
3. Two-Pointer / Sliding Window – do right after 1 & 2
   Core: 3, 76, 567, 424, 438
4. Stack / Monotonic Stack
   Patterns: next-greater, span, histogram, parentheses matching.
   Core: 20, 155, 739, 901, 84
5. Linked List Fundamentals
   Patterns: slow-fast pointer, list reversal, merge two lists.
   Core: 21, 206, 141, 142, 234

⸻

Stage 2 – Non-Linear Structures (≈ 3 weeks) 6. Binary Trees (DFS & BFS) – traversals, diameter
Core: 104, 102, 226, 124, 105 7. BST & Balanced Trees – validate, kth-smallest, LCA
Core: 98, 230, 235, 236, 110 8. Heaps / Priority Queue – top-K, merge lists, running median
Core: 215, 295, 347, 23, 502 9. Intervals & Greedy – sort-sweep, meeting rooms, erase overlap
Core: 56, 253, 621, 452, 435 10. Recursion & Backtracking – choose-for-loop-recurse-unchoose
Core: 46, 78, 79, 90, 39

⸻

Stage 3 – “Big 3” Interview Killers (≈ 4 weeks) 11. Binary Search (value & answer space) – rotated array, capacity-days
Core: 33, 153, 74, 875, 410 12. Dynamic Programming – 1-D – climbing stairs, house robber, word break
Core: 70, 198, 213, 746, 139 13. Dynamic Programming – 2-D / Subsequence – LIS, LCS, edit dist.
Core: 1143, 300, 221, 322, 72 14. Graph Traversal – connected comps, topo sort, rotten oranges
Core: 200, 417, 994, 207, 133 15. Graph Algorithms – Dijkstra, 0-1 BFS, Union-Find, MST
Core: 743, 1514, 787, 399, 261

⸻

Stage 4 – Polish & Edge Topics (≈ 2 weeks, parallel with mocks) 16. Tries / String DS – 208, 212, 648 17. Bit Manipulation – 191, 231, 136, 137, 371 18. Segment / Fenwick Trees – 307, 308, 732 19. Geometry / Math – 149, 593, 223, 233

(Only dive deep if the target companies are known to ask these.)

⸻

How to Practice Each Problem

1. Re-implement from scratch (≤ 20 min).
2. Flash-explain aloud (≤ 2 min).
3. Edge-case drill – list three tricky inputs and trace.
4. Complexity talk-through – note O(time)/O(space) & alternatives.

⸻

Weekly Rhythm Example

Day Morning (1 h) Evening (1–2 h)
Mon New-topic theory ＋ 2 easies 1 medium
Tue 2 mediums 1 hard or 2 mediums
Wed Review + 1 easy 1–2 mediums
Thu 1 hard Mock interview (peer/Pramp)
Fri Flash-card review Light solve or rest
Sat Re-solve entire week’s set from scratch
Sun Break / System-design study

⸻

Final 10-Day Sprint Before Interviews

1. Mix daily: 1 easy : 2 mediums : 1 hard (random topics).
2. For every miss, jot a 3-line “Why I missed?” note.
3. Alternate days with full mock interviews.

⸻

One-Pager TL;DR

Arrays → HashMap → Sliding Window → Stack → Linked List
Trees → Heap → Intervals → Backtracking
Binary Search → DP-1D → DP-2D → Graph-Basic → Graph-Advanced
(Trie / Bit / Segment) if needed

Follow that sequence with consistent daily reps, and you’ll cover ~90 % of questions asked in FAANG-style coding interviews. Happy grinding!
